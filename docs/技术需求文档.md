# **技术需求文档**

## 🏗️ **MVP架构**

```
输入层（API 调用）
├── Polymarket yes价格
├── Deribit期权价格
└── BTC现货价格

计算层（核心）
├── 概率转换器（1个函数）
├── 保证金计算器（1个函数）
├── P&L计算器（1个函数）
└── 成本估算器（1个函数）

输出层（简单）
└── 命令行结果：是/否有套利机会 + 预期收益
```

## 📋 **MVP 功能**

1. **单一市场分析**：一次只分析一个 Polymarket 事件
2. **手动数据输入**：通过配置文件或命令行参数输入价格
3. **核心算法验证**：概率转换 + 保证金计算 + P&L计算
4. **基础成本估算**：交易费 + 基础保证金成本

---

## **开发计划**

### **第1阶段：核心算法（1天）**

```python
# 文件：calculator.py
def bs_probability(spot, strike, time, volatility, rate=0.05):
    """Black-Scholes概率计算"""
    pass

def calculate_margin(contract_size, risk_factor, premium):
    """保证金计算"""
    pass

def calculate_pnl(poly_price, deribit_prob, investment, costs):
    """P&L计算"""
    pass

```

### **第2阶段：数据接口（0.5 天）**

```python
# 文件：data_loader.py
def load_manual_data():
    """从配置文件加载手动输入的数据"""
    pass

# 或API调用
def fetch_single_market_data(market_id):
    """获取单个市场数据"""
    pass

```

### **第3阶段：结果输出（1 天）**

```python
# 文件：main.py
def main():
    data = load_manual_data()
    prob = bs_probability(...)
    margin = calculate_margin(...)
    pnl = calculate_pnl(...)

    print(f"套利机会: {'存在' if pnl > 20 else '不存在'}")
    print(f"预期收益: ${pnl:.2f}")

```

---

## 📊 **MVP输入输出示例**

### **输入（手动配置文件）**

```yaml
# config.yaml
polymarket:
  market_id: "btc-above-114k"
  yes_price: 0.12

deribit:
  spot_price: 60000
  k1_strike: 113000
  k2_strike: 115000
  k1_option_price: 0.015  # BTC
  k2_option_price: 0.008  # BTC

investment: 5000
```

### **输出（命令行）**

```
=== 套利机会分析 ===
市场: btc-above-114k
Polymarket概率: 12.0%
Deribit隐含概率: 8.2%
价差: 3.8%

策略一预期收益: $128.50
策略二预期收益: $45.20

建议: 存在套利机会，推荐策略一
```

---

## 🔍 **MVP验证方法**

### **验证步骤**

1. **选取2个历史事件**（已结算的Polymarket市场）
2. **收集数据**（当时的Poly价格 + Deribit期权价格）
3. **运行MVP计算**套利机会
4. **与实际结果对比**验证算法准确性

### **成功指标**

- 算法计算 vs 手动计算结果误差 < 5%
- `平均收益 > $50/机会`
- 核心计算时间 < 1秒