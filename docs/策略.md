# 项目算法与流程说明

>   文档基于当前代码版本整理：
>
>   -   `strategy/models.py` models
>   -   `strategy/strategy.py` strategy
>   -   `strategy/position_calculator.py` position_calculator
>   -   `strategy/probability_engine.py` probability_engine
>   -   `strategy/investment_runner.py` investment_runner
>   -   `main.py` / 轮询逻辑 main

------

## 0. 记号与输入参数定义

核心输入类 `CalculationInput`：models

-   SSS：`S`，当前 BTC 现货价格（USD）
-   KKK：`K`，参考行权价（通常取 K1K_1K1）
-   TTT：`T`，剩余到期时间（年）
-   rrr：`r`，年化无风险利率
-   σ\sigmaσ：`sigma`，年化隐含波动率

区间相关行权价：

-   K1K_1K1：`K1`，区间1下界（较低的 Deribit 行权价）
-   KpolyK_{\text{poly}}Kpoly：`K_poly`，Polymarket 事件边界（BTC 是否高于该价）
-   K2K_2K2：`K2`，区间2上界（较高的 Deribit 行权价）

投资与价格：

-   `Inv_Base`：在 Polymarket 上的名义投资额（USDC）
-   `Call_K1_Bid`：K1K_1K1 看涨期权 Bid（卖出 K1 call 时收到的价格，USD）
-   `Call_K2_Ask`：K2K_2K2 看涨期权 Ask（买入 K2 call 时支付的价格，USD）
-   `Call_K1_Ask`：K1K_1K1 看涨期权 Ask
-   `Call_K2_Bid`：K2K_2K2 看涨期权 Bid
-   `Price_No_entry`：Polymarket NO 价格
-   `Price_Option1`：K1 期权中间价
-   `Price_Option2`：K2 期权中间价
-   `BTC_Price`：现货 BTC 价格（通常与 `S` 一致）
-   `Slippage_Rate`：统一使用的滑点率（0–1）
-   `Total_Investment`：整体投资额（目前等于 `Inv_Base`）

PME 保证金与合约数量：

-   `pme_params`：PME 参数，用于保证金风控 models
-   `contracts`：牛市价差的合约数
-   `days_to_expiry`：到期剩余天数（用于 PME 计算）

------

## 1. 概率模块：Black-Scholes 与区间概率

### 1.1 风险中性概率 P(ST>K)P(S_T > K)P(ST>K)

函数：`bs_probability_gt(S, K, T, sigma, r)` probability_engine

实现公式（Black-Scholes 风险中性概率）：

d2=ln⁡(SK)+(r−12σ2)TσTd_2 = \frac{\ln(\frac{S}{K}) + (r - \frac{1}{2}\sigma^2)T}{\sigma\sqrt{T}}d2=σTln(KS)+(r−21σ2)TP(ST>K)=Φ(d2)P(S_T > K) = \Phi(d_2)P(ST>K)=Φ(d2)

其中 Φ(⋅)\Phi(\cdot)Φ(⋅) 是标准正态分布 CDF（代码用 `erf` 实现）。probability_engine

边界处理：

-   S≤0S \le 0S≤0 或 K≤0K \le 0K≤0：直接报错
-   T≤0T \le 0T≤0：
    -   S>KS > KS>K：返回 0.99999
    -   S<KS < KS<K：返回 0.00001
    -   S=KS = KS=K：返回 0.5 probability_engine
-   σ≤0\sigma \le 0σ≤0：返回 111（若 S>KS > KS>K）或 000（若 S≤KS \le KS≤K）

### 1.2 四个价格区间的概率

函数：`interval_probabilities(S, K1, K_poly, K2, T, sigma, r)` probability_engine

定义四个区间：

1.  ST<K1S_T < K_1ST<K1
2.  K1≤ST<KpolyK_1 \le S_T < K_{\text{poly}}K1≤ST<Kpoly
3.  Kpoly≤ST<K2K_{\text{poly}} \le S_T < K_2Kpoly≤ST<K2
4.  ST≥K2S_T \ge K_2ST≥K2

实现方法：

1.  先用上面的 `bs_probability_gt` 计算三个点的尾部概率：

    p≥K1=P(ST≥K1),p≥Kpoly,p≥K2p_{\ge K_1} = P(S_T \ge K_1),\quad p_{\ge K_{\text{poly}}},\quad p_{\ge K_2}p≥K1=P(ST≥K1),p≥Kpoly,p≥K2

    probability_engine

2.  再构造成区间概率：

P(ST<K1)=1−p≥K1P(K1≤ST<Kpoly)=max⁡(0, p≥K1−p≥Kpoly)P(Kpoly≤ST<K2)=max⁡(0, p≥Kpoly−p≥K2)P(ST≥K2)=p≥K2\begin{aligned} P(S_T < K_1) &= 1 - p_{\ge K_1} \\ P(K_1 \le S_T < K_{\text{poly}}) &= \max\bigl(0,\, p_{\ge K_1} - p_{\ge K_{\text{poly}}}\bigr) \\ P(K_{\text{poly}} \le S_T < K_2) &= \max\bigl(0,\, p_{\ge K_{\text{poly}}} - p_{\ge K_2}\bigr) \\ P(S_T \ge K_2) &= p_{\ge K_2} \end{aligned}P(ST<K1)P(K1≤ST<Kpoly)P(Kpoly≤ST<K2)P(ST≥K2)=1−p≥K1=max(0,p≥K1−p≥Kpoly)=max(0,p≥Kpoly−p≥K2)=p≥K2

最后对四个概率做一次归一化，确保和为 1。probability_engine

### 1.3 完整概率结构（`calculate_probabilities`）

在 `strategy.strategy.calculate_probabilities` 中：strategy

-   事件定义：**Polymarket 事件 = ST>KpolyS_T > K_{\text{poly}}ST>Kpoly**

-   中间步骤：

    1.  用 KpolyK_{\text{poly}}Kpoly 计算 d1,d2d_1, d_2d1,d2：

        d1=ln⁡(SKpoly)+(r+12σ2)TσT,d2=d1−σTd_1 = \frac{\ln(\frac{S}{K_{\text{poly}}}) + (r + \frac{1}{2}\sigma^2)T}{\sigma\sqrt{T}},\quad d_2 = d_1 - \sigma\sqrt{T}d1=σTln(KpolyS)+(r+21σ2)T,d2=d1−σT

    2.  PST>K=Φ(d2)P_{ST> K} = \Phi(d_2)PST>K=Φ(d2)，用来表示事件概率（直观上应接近 Deribit implied probability）。

    3.  对 K1,Kpoly,K2K_1, K_{\text{poly}}, K_2K1,Kpoly,K2 分别求 d2d_2d2，按上节公式得到四个区间概率，并归一化。

------

## 2. 策略结构与头寸规模

策略有两条主线：

-   **策略1：买 PM YES + 卖 DR 牛市价差**
-   **策略2：买 PM NO + 买 DR 牛市价差**

### 2.1 Deribit 牛市价差 Payoff

牛市价差结构（K1 < K2，call）：

-   多头牛市价差：多 K1K_1K1 call，空 K2K_2K2 call；
-   空头牛市价差：空 K1K_1K1 call，多 K2K_2K2 call。

**一份牛市价差到期内在价值**（不考虑合约数量）：

intrinsic(ST)={0,ST≤K1ST−K1,K1<ST<K2K2−K1,ST≥K2\text{intrinsic}(S_T) = \begin{cases} 0, & S_T \le K_1 \\ S_T - K_1, & K_1 < S_T < K_2 \\ K_2 - K_1, & S_T \ge K_2 \end{cases}intrinsic(ST)=⎩⎨⎧0,ST−K1,K2−K1,ST≤K1K1<ST<K2ST≥K2

代码中在 payoff 计算时，先算 `intrinsic` 然后乘以 `contracts`。strategy

------

### 2.2 头寸估算（`position_calculator.py`）

#### 2.2.1 公共输入

```
@dataclass
class PositionInputs:
    inv_base_usd: float   # 基础投资额（USD）
    call_k1_bid_btc: float
    call_k2_ask_btc: float
    call_k1_ask_btc: float
    call_k2_bid_btc: float
    btc_usd: float        # BTC/USD 现价
``` :contentReference[oaicite:16]{index=16}  

`inv_base_btc = inv_base_usd / btc_usd`：把资金换算成 BTC 计价。

#### 2.2.2 策略1：卖牛市价差（做空）

函数：`strategy1_position_contracts` :contentReference[oaicite:17]{index=17}  

- 每份牛市价差在 BTC 计价下的净收入：
  \[
  \text{net\_cost} = \text{call\_k1\_bid\_btc} - \text{call\_k2\_ask\_btc}
  \]
- 若 `net_cost <= 0`，返回 0（无套利空间）。
- 否则合约数：
  \[
  \text{contracts}_1 = \frac{\text{inv\_base\_btc}}{\text{net\_cost}}
  \]

**理解**：用基础 BTC 资金除以每份牛市价差带来的收入，得到“最多能卖多少份牛市价差”。

#### 2.2.3 策略2：买牛市价差（做多）

函数：`strategy2_position_contracts` :contentReference[oaicite:18]{index=18}  

- 先计算：
  \[
  \text{net\_cost} = \text{call\_k2\_ask\_btc} - \text{call\_k1\_bid\_btc}
  \]
- 若 `net_cost <= 0`，同样返回 0。
- 否则：
  \[
  \text{contracts}_2 = \frac{\text{inv\_base\_btc}}{\text{net\_cost}}
  \]

**理解**：这里用“买一个牛市价差需要的净支出”来决定能买多少份。

#### 2.2.4 用于 IM 测算的合约数

在 `evaluate_investment` 中，先计算 S1 和 S2 的合约数，然后取绝对值的上界：:contentReference[oaicite:19]{index=19}  

```python
amount_contracts = max(abs(contracts_s1), abs(contracts_s2))
```

这个 `amount_contracts` 用于 Deribit 初始保证金和后续 PME 保证金计算。

------

### 2.3 高层策略规模计算（`strategy.calculate_strategy1/2`）

这两函数与上面 BTC 版本思想一致，但在 USD 维度上重算一次，用于 EV 模型。strategy

#### 2.3.1 策略1

```
Income_Deribit = Call_K1_Bid - Call_K2_Ask
Contracts_Short = Inv_Base / Income_Deribit if Income_Deribit != 0 else 0
```

-   每份牛市价差收到的净收入（USD）：

    Income_Deribit=Call_K1_Bid−Call_K2_Ask\text{Income\_Deribit} = \text{Call\_K1\_Bid} - \text{Call\_K2\_Ask}Income_Deribit=Call_K1_Bid−Call_K2_Ask

-   合约数：

    Contracts_Short=Inv_BaseIncome_Deribit\text{Contracts\_Short} = \frac{\text{Inv\_Base}}{\text{Income\_Deribit}}Contracts_Short=Income_DeribitInv_Base

#### 2.3.2 策略2

```
Profit_Poly_Max = Inv_Base * (1 / Price_No_entry - 1)
Cost_Deribit = Call_K1_Ask - Call_K2_Bid
Contracts_Long = Profit_Poly_Max / Cost_Deribit if Cost_Deribit != 0 else 0
``` :contentReference[oaicite:21]{index=21}  

- 在 PM NO 头寸上的最大收益：
  \[
  \text{Profit\_Poly\_Max} = \text{Inv\_Base} \cdot \left(\frac{1}{P_{\text{NO}}} - 1\right)
  \]
  其中 \(P_{\text{NO}} = \text{Price\_No\_entry}\)。
- 每份多头牛市价差的成本：
  \[
  \text{Cost\_Deribit} = \text{Call\_K1\_Ask} - \text{Call\_K2\_Bid}
  \]
- 合约数：
  \[
  \text{Contracts\_Long} = \frac{\text{Profit\_Poly\_Max}}{\text{Cost\_Deribit}}
  \]

**直觉**：让 DR 端的最大盈利规模与 PM 端最大盈利大致匹配。

---

## 3. 成本与保证金（PME 风险矩阵）

核心函数：`calculate_costs(input_data, use_pme_margin=True)` :contentReference[oaicite:22]{index=22}  

### 3.1 开仓成本（Open_Cost）

```python
deribit_fee = calculate_deribit_bull_spread_entry_cost(...)
blockchain_open = 0.025
open_cost = deribit_fee + blockchain_open
``` :contentReference[oaicite:23]{index=23}  

#### 3.1.1 Deribit Taker Fee

单腿期权 Taker Fee：:contentReference[oaicite:24]{index=24}  

\[
\text{TakerFee} = \min(0.0003 \times \text{index\_price},\; 0.125 \times \text{option\_price}) \times \text{contracts}
\]

再加上固定每份滑点 `slippage_per_contract`：

\[
\text{EntryCost\_single\_leg} = \text{slippage\_per\_contract} \times \text{contracts} + \text{TakerFee}
\]

牛市价差的组合费用采用“组合折扣”：两腿费用取最大值：

\[
\text{EntryCost\_BullSpread} = \max(\text{fee\_K1},\; \text{fee\_K2})
\]

#### 3.1.2 Polymarket 开仓链上费用

`blockchain_open = 0.025`（固定常数，USDC）。

因此：

\[
\text{Open\_Cost} = \text{EntryCost\_BullSpread} + 0.025
\]

---

### 3.2 PME 保证金（C_DR）的计算

函数：`calculate_pme_margin` :contentReference[oaicite:25]{index=25}  

1. **构造价格场景**：`_build_price_scenarios`
   - 主表：价格从 \(-16\%\) 到 \(+16\%\)，步长 2%，即 \(\{-0.16, -0.14, ..., 0.16\}\)。
   - 扩展表：\([-66\%, -50\%, -33\%, +33\%, +50\%, +100\%, +200\%, +500\%]\)。:contentReference[oaicite:26]{index=26}  

   每个场景给出：
   \[
   S_{\text{sim}} = S_{\text{current}} \cdot (1 + \text{price\_move})
   \]

2. **vegaPower** 的计算（控制波动率冲击幅度）：

```python
if days_to_expiry < 30:
    vega_power = short_term_vega_power
else:
    vega_power = long_term_vega_power
``` :contentReference[oaicite:27]{index=27}  

默认：短期 0.30，长期 0.50。:contentReference[oaicite:28]{index=28}  

3. **模拟波动率** `_calculate_simulated_volatility`：:contentReference[oaicite:29]{index=29}  

时间因子：

\[
\text{time\_factor} = \left(\frac{30}{\text{days\_to\_expiry}}\right)^{\text{vegaPower}}
\]

- vol_shock = "up"：
  \[
  \sigma_{\text{sim}} = \sigma_{\text{current}} \cdot \bigl(1 + \text{time\_factor} \cdot \text{vol\_range\_up}\bigr)
  \]
- vol_shock = "down"：
  \[
  \sigma_{\text{sim}} = \sigma_{\text{current}} \cdot \bigl(1 - \text{time\_factor} \cdot \text{vol\_range\_down}\bigr)
  \]
- "unchanged"：\(\sigma_{\text{sim}} = \sigma_{\text{current}}\)

4. **单个期权头寸在场景下的 PnL** `_calculate_position_pnl` :contentReference[oaicite:30]{index=30}  

以 call 为例：

\[
\begin{aligned}
\text{intrinsic\_current} &= \max(S_{\text{current}} - K, 0) \\
\text{intrinsic\_sim} &= \max(S_{\text{sim}} - K, 0) \\
\Delta \text{intrinsic} &= \text{intrinsic\_sim} - \text{intrinsic\_current}
\end{aligned}
\]

简化 vega 线性近似：

\[
\Delta \sigma = \sigma_{\text{sim}} - \sigma_{\text{current}},\quad
\text{vega\_effect} = \Delta \sigma \cdot \text{current\_price} \cdot 0.1
\]

每份合约损益：

\[
\text{pnl\_per\_contract} = \Delta \text{intrinsic} + \text{vega\_effect}
\]

考虑多空方向和合约数：

\[
\text{PnL} = \text{pnl\_per\_contract} \times \text{contracts} \times (\pm 1)
\]

（多头 `+1`，空头 `-1`）

5. **Extended Dampener**（用于极端价格场景） `_apply_extended_dampener` :contentReference[oaicite:31]{index=31}  

若为扩展表场景：

- \( \text{ratio} = \max\left(\frac{|\text{price\_move}|}{\text{price\_range}}, 1\right) \)
- \( \text{max\_adjustment} = (\text{ratio} - 1) \cdot \text{extended\_dampener} \)
- 实际调整：
  \[
  \text{adjustment} = \min(\text{max\_adjustment}, |\text{simulated\_pnl}|)
  \]

- 若 PnL < 0：往 0 拉近（损失减小）  
- 若 PnL > 0：往 0 拉近（盈利减少）

6. **最终保证金结果**

对所有场景求和形成 `total_pnl`，取最坏情形：

\[
\text{worst\_pnl} = \min(\text{total\_pnl over all scenarios})
\]

\[
C_{DR} = |\text{worst\_pnl}|
\]

即 PME 保证金 = 所有模拟场景下的最大亏损绝对值。:contentReference[oaicite:32]{index=32}  

### 3.3 持仓成本（Holding_Cost）

若 `use_pme_margin=True`，则：

```python
margin_requirement = pme_margin_usd
margin_cost = margin_requirement * r * (holding_days / 365)
opportunity_cost = Total_Investment * r * (holding_days / 365)
holding_cost = margin_cost + opportunity_cost
``` :contentReference[oaicite:33]{index=33}  

公式：

\[
\text{margin\_cost} = C_{DR} \cdot r \cdot \frac{\text{days\_to\_expiry}}{365}
\]

\[
\text{opportunity\_cost} = \text{Total\_Investment} \cdot r \cdot \frac{\text{days\_to\_expiry}}{365}
\]

\[
\text{Holding\_Cost} = \text{margin\_cost} + \text{opportunity\_cost}
\]

---

### 3.4 平仓成本（Close_Cost）

```python
pm_slippage = Inv_Base * Slippage_Rate
settlement_fee = calculate_deribit_settlement_fee(...)
blockchain_close = 0.025
close_cost = pm_slippage + settlement_fee + blockchain_close
``` :contentReference[oaicite:34]{index=34}  

Deribit 结算费公式：:contentReference[oaicite:35]{index=35}  

\[
\text{SettlementFee} =
\min\bigl(0.00015 \times \text{settlement\_price},\; 0.125 \times \text{expected\_option\_value}\bigr) \times \text{contracts}
\]

所以：

\[
\text{Close\_Cost} = \text{Inv\_Base} \cdot \text{Slippage\_Rate}
+ \text{SettlementFee} + 0.025
\]

### 3.5 总成本（Total_Cost）

\[
\text{Total\_Cost} = \text{Open\_Cost} + \text{Holding\_Cost} + \text{Close\_Cost}
\]

在 `CostOutput` 中统一返回。:contentReference[oaicite:36]{index=36}  

---

## 4. 收益与 EV 计算

### 4.1 策略 1：买 YES + 卖牛市价差 Payoff

内部函数：`_portfolio_payoff_at_price_strategy1` :contentReference[oaicite:37]{index=37}  

1. **PM YES 部分**  

设：

- \(I = \text{Inv\_Base}\)
- YES 价格 \(p_Y = \text{pm\_yes\_price}\)（从 `pm_yes_price` 参数传入，并存为全局变量）  

买入 YES token 数量：

\[
N_Y = \frac{I}{p_Y}
\]

到期事件定义：\(S_T > K_{\text{poly}}\)。

- 若事件发生：每个 YES 支付 1 USDC，总兑付 \(N_Y\)，PnL：
  \[
  \text{PnL}_{PM} = N_Y - I
  \]
- 若事件不发生：
  \[
  \text{PnL}_{PM} = -I
  \]

2. **DR 卖出牛市价差**  

单份牛市价差信用：

\[
\text{credit} = \text{Call\_K1\_Bid} - \text{Call\_K2\_Ask}
\]

给定合约数 \(C = \text{strategy\_out.Contracts}\)：

- 到期内在价值 `intrinsic` 按 2.1 那个分段函数 × C 计算：
  \[
  \text{intrinsic}_C(S_T) =
  \begin{cases}
  0, & S_T \le K_1\\
  (S_T - K_1) C, & K_1 < S_T < K_2\\
  (K_2 - K_1) C, & S_T \ge K_2
  \end{cases}
  \]
- 卖出牛市价差的 PnL：
  \[
  \text{PnL}_{DR} = \text{credit} \cdot C - \text{intrinsic}_C(S_T)
  \]

3. **总 PnL**：

\[
\text{TotalPnL}_1(S_T) = \text{PnL}_{PM} + \text{PnL}_{DR}
\]

---

### 4.2 策略 2：买 NO + 买牛市价差 Payoff

函数：`_portfolio_payoff_at_price_strategy2` :contentReference[oaicite:38]{index=38}  

1. **PM NO 部分**

NO 价格 \(p_N = \text{Price\_No\_entry}\)：

\[
N_N = \frac{I}{p_N}
\]

- 若事件 **不发生**（\(S_T \le K_{\text{poly}}\)）：NO 支付 1，PnL：
  \[
  \text{PnL}_{PM} = N_N (1 - p_N) = I\left(\frac{1}{p_N} - 1\right)
  \]
- 若事件发生：PnL = \(-I\)

2. **DR 多头牛市价差**

\[
\text{cost\_deribit} = \text{Call\_K1\_Ask} - \text{Call\_K2\_Bid}
\]

同样定义 `intrinsic_C(S_T)`。合约数 \(C\) 为 `strategy2.Contracts`：

\[
\text{PnL}_{DR} = \text{intrinsic}_C(S_T) - \text{cost\_deribit} \cdot C
\]

3. **总 PnL**：

\[
\text{TotalPnL}_2(S_T) = \text{PnL}_{PM} + \text{PnL}_{DR}
\]

---

### 4.3 EV 计算（细网格积分）

函数：`_integrate_ev_over_grid` :contentReference[oaicite:39]{index=39}  

1. 构造价格网格 `grid`：:contentReference[oaicite:40]{index=40}  

- 区间范围：
  \[
  [K_1 - 10000,\; K_2 + 10000]
  \]
- 总点数约 100：20% 左尾，60% 中间，20% 右尾。

2. 对每个网格点 \(x_i\) 计算：

\[
p_{\ge x_i} = P(S_T \ge x_i)
\]

使用上面的 `bs_probability_gt` 实现。:contentReference[oaicite:41]{index=41}  

3. 相邻区间的概率：

\[
p_i = \max\bigl(0,\, p_{\ge x_i} - p_{\ge x_{i+1}}\bigr)
\]

这样 \(p_i \approx P(x_i \le S_T < x_{i+1})\)。

4. 对每个区间，用左端点 \(x_i\) 的 payoff 代表该区间：

- 策略1：用 `_portfolio_payoff_at_price_strategy1`
- 策略2：用 `_portfolio_payoff_at_price_strategy2`

得到：

\[
(\text{PnL}_{PM,i},\; \text{PnL}_{DR,i},\; \text{TotalPnL}_i)
\]

5. 期望值：

\[
\begin{aligned}
E_{PM} &= \sum_i p_i \cdot \text{PnL}_{PM,i} \\
E_{DR} &= \sum_i p_i \cdot \text{PnL}_{DR,i} \\
\text{GrossEV} &= E_{PM} + E_{DR}
\end{aligned}
\]

6. 净 EV（扣成本）：

\[
\text{NetEV} = \text{GrossEV} - \text{Total\_Cost}
\]

最终返回：

- `ExpectedPnlOutput` 中：
  - `E_Poly_PnL = E_PM`
  - `E_Deribit_PnL = E_DR`
  - `Total_Expected = NetEV` :contentReference[oaicite:42]{index=42}  

---

## 5. 年化指标与 BS 快速筛选

### 5.1 年化指标（RoC / Sharpe）

函数：`calculate_annualized_metrics` :contentReference[oaicite:43]{index=43}  

输入：

- `expected_pnl.Total_Expected`：净 EV
- `total_capital`：总锁定资金（主函数中实际使用的是 `Total_Investment + PME_Margin_USD`）
- `days_to_expiry`
- `risk_free_rate = r`
- `volatility = sigma`

计算：

\[
\text{RoC} = \frac{\text{EV}}{\text{total\_capital}}
\]

\[
\text{Annualized\_RoC} = \text{RoC} \cdot \frac{365}{\text{days\_to\_expiry}}
\]

\[
\text{ExcessReturn} = \text{Annualized\_RoC} - r
\]

若 \(\sigma > 0\)，夏普比率：

\[
\text{Sharpe} = \frac{\text{ExcessReturn}}{\sigma}
\]

写入 `AnnualizedMetrics`。:contentReference[oaicite:44]{index=44}  

### 5.2 BS Pricer 快速筛选与 Greeks（注意：实现处有一个疑似公式问题）

类：`BlackScholesPricer` :contentReference[oaicite:45]{index=45}  

#### 5.2.1 概率 ITM

`calculate_probability_itm` 里使用标准 Black-Scholes：

\[
d_1 = \frac{\ln(\frac{S}{K}) + (r + \frac{1}{2}\sigma^2)T}{\sigma\sqrt{T}},\quad
d_2 = d_1 - \sigma\sqrt{T}
\]
\[
\text{prob\_itm} = \Phi(d_2)
\]

#### 5.2.2 定价偏差筛选 `compare_with_polymarket`

- `edge = bs_prob - pm_yes_price`
- 若 \(|\text{edge}| < \text{threshold}`（默认 3%）：信号 `no_trade`
- 若 `edge > 0`：BS 概率更高 → PM YES 被低估 → 信号 `buy_yes`
- 若 `edge < 0`：BS 概率更低 → PM YES 被高估 → 信号 `buy_no` :contentReference[oaicite:46]{index=46}  

#### 5.2.3 Greeks 计算（⚠️ 这里实现中把 CDF 当成 PDF 使用）

按注释：应是

- \(\Delta_{\text{call}} = \Phi(d_1)\)
- \(\Gamma = \frac{\phi(d_1)}{S\sigma\sqrt{T}}\)
- \(\nu = S \phi(d_1)\sqrt{T}\)
- \(\Theta_{\text{call}} = -\frac{S\phi(d_1)\sigma}{2\sqrt{T}} - rK e^{-rT}\Phi(d_2)\)

**但代码里**：

```python
phi_d1 = _norm_cdf(d1)  # 注释写 φ(d1)，实际上实现的是 Φ(d1)
Phi_d1 = _norm_cdf(d1)
Phi_d2 = _norm_cdf(d2)
gamma = phi_d1 / (S * sigma * sqrt_T)
vega = S * phi_d1 * sqrt_T
``` :contentReference[oaicite:47]{index=47}  

即用 CDF 代替了 PDF（密度函数），这和标准 BS 公式不一致 —— 如果你是在核对公式正确性，这里是一个需要特别注意/整改的点。

---

## 6. `evaluate_investment` 整体流程

函数：`evaluate_investment`（策略级别入口） :contentReference[oaicite:48]{index=48}  

给定：

- 投资基数 `inv_base_usd`
- 当前 Deribit/PM 行情（`DeribitMarketContext` / `PolymarketState`）
- Deribit 用户配置（用于获取初始保证金）

步骤：

1. **估计 Polymarket 滑点**

   对 YES/NO，两侧都调用 `get_polymarket_slippage`，分别模拟：

   - 买入 `inv_base_usd`（USD）金额；
   - 再按买到的 shares 卖出，得到平仓滑点。

   记录：

   - 平均成交价 `avg_price`
   - `shares_executed`
   - 滑点百分比 `slippage_pct / 100` :contentReference[oaicite:49]{index=49}  

   最后取  

   ```python
   slippage_rate_used = max(pm_yes_slip_open, pm_no_slip_open)
```

1.  **计算头寸合约数**

    使用 `PositionInputs` + `strategy1_position_contracts` / `strategy2_position_contracts`，得到 `contracts_s1` / `contracts_s2`，取最大绝对值作为 `amount_contracts`。investment_runner

2.  **获取 Deribit 初始保证金（IM）**

    ```
    im_value_btc = get_testnet_initial_margin(..., amount=amount_contracts, instrument_name=inst_k1)
    im_value_usd = im_value_btc * spot
    ``` :contentReference[oaicite:51]{index=51}  
    ```

3.  **构造 `CalculationInput`**

    -   把当前 S,K1,K2,Kpoly,T,r,σS, K_1, K_2, K_{\text{poly}}, T, r, \sigmaS,K1,K2,Kpoly,T,r,σ、
    -   各个期权价格（Bid/Ask/Mid）、`Price_No_entry`、`Slippage_Rate`、
    -   `Margin_Requirement = im_value_usd`、`Total_Investment = inv_base_usd`、
    -   `contracts = amount_contracts`、`days_to_expiry = T * 365.0`

    写入 `CalculationInput` 实例。investment_runner

4.  **调用核心计算引擎**

    ```
    result = main_calculation(
        calc_input,
        use_pme_margin=True,
        calculate_annualized=True,
        pm_yes_price=poly_ctx.yes_price,
        calculate_greeks=False,
        bs_edge_threshold=0.03,
    )
    ``` :contentReference[oaicite:53]{index=53}  
    
    - 使用 PME 重新计算保证金（覆盖原始 `Margin_Requirement`）；
    - 基于 PM YES 价格做 BS 定价偏差筛选（但结果只是作为附加信息）；
    - 默认不算 Greeks。
    ```

5.  **提取 EV & 成本，包装成 `InvestmentResult`**

    ```
    ev_yes = result.expected_pnl_strategy1.Total_Expected
    ev_no  = result.expected_pnl_strategy2.Total_Expected
    total_costs_* = result.costs.Total_Cost
    ``` :contentReference[oaicite:54]{index=54}  
    
    返回 `InvestmentResult`，其中包含 `calc_input`，后续提前平仓分析会用到。:contentReference[oaicite:55]{index=55}  
    ```

------

## 7. 提前平仓 / 早退接口（概览）

在 `investment_runner.py` 中：investment_runner

```
async def evaluate_early_exit_for_position(
    position: Position,
    base_result: InvestmentResult,
    settlement_price: float,
    pm_exit_price: float,
    available_liquidity_tokens: float,
    early_exit_cfg: Dict[str, Any],
) -> ExitDecision:
    ...
    decision = make_exit_decision(...)
```

要点：

-   `position`：真实持仓（PM token 数量 + DR 合约数量 + 成本）在 `Position` 数据类中定义。models
-   `base_result.calc_input`：用初始投资时的模型参数作为“基线场景”。
-   `make_exit_decision`（在 `strategy.early_exit` 中）会结合：
    -   当前 PM exit price；
    -   假设持有到结算的理论收益；
    -   PME/风险约束；
         给出是否提前平仓的建议 `ExitDecision`。

**注意**：`early_exit` 具体算法不在本次代码片段中，要做公式检查需要打开对应文件再写一节。

------

## 8. 外层监控与事件构建（`main.py` 概览）

1.  **事件模板与日期旋转**：`rotate_event_title_date`
    -   把 config 中的 `"Bitcoin above ___ on November 17?"` 这类模板中的日期替换成目标日期（如 “November 21”），其他文字保持不变。main
2.  **自动发现所有 strike 市场**：`discover_strike_markets_for_event`
    -   调用 Polymarket API，找到某事件下所有子市场；
    -   从 `groupItemTitle` / `question` 中用正则提取如 `"100,000"` 等数字，作为 strike。main
3.  **根据 offset 生成 Deribit strikes**：`build_events_for_date`
    -   对每个 strike，生成：
        -   `K_poly = strike`
        -   `K1 = strike + k1_offset`
        -   `K2 = strike + k2_offset` main
4.  **循环事件计算**：`loop_event`
    -   基于配置与行情构造 `DeribitMarketContext` / `PolymarketState`；
    -   调用 `evaluate_investment` 对不同投资额算 EV；
    -   将结果打印 + 写入 CSV。main

------

## 9. 公式检查时建议重点关注的点

如果你现在要逐条检查“公式是否正确”，建议优先看：

1.  **Greeks 部分**（`BlackScholesPricer.calculate_greeks`）
    -   代码中 `phi_d1` 实际用的是 CDF Φ(d1)\Phi(d_1)Φ(d1)，而注释写的是 PDF ϕ(d1)\phi(d_1)ϕ(d1)，目前的实现与标准 BS 公式不一致（Gamma/Vega/Theta 会有系统性偏差）。strategy
2.  **EV 网格积分**
    -   `_integrate_ev_over_grid` 使用 `P(S_T \ge x_i) - P(S_T \ge x_{i+1})` 构造区间概率，这在数学上是合理的；
    -   可以重点检查网格范围 `[K1 - 10000, K2 + 10000]` 对你的实际标的价格分布是否足够宽。strategy
3.  **PME 模型参数**
    -   `short_term_vega_power`、`long_term_vega_power`、`vol_range_up/down`、`extended_dampener` 等参数会直接影响保证金 CDRC_{DR}CDR 的大小，可以对照你目标的风险矩阵规则逐项验证。models
4.  **头寸规模的一致性**
    -   `position_calculator` 里用 BTC 价格算的合约数，`strategy.calculate_strategy1/2` 里又用 USD 逻辑算了一遍，两者一致性如何，是可以再对照一下看是不是你想要的结构。